from __future__ import absolute_import
from __future__ import print_function
import numpy as np
from psi4.driver.qcdb import periodictable
from psi4.driver.qcdb import physconst
import BFS_bonding


class Molecule(object):
    def __init__(self, z_vals, xyz, unit='Angstrom'):
        """
        Molecule objects are used for passing information between Psi4 and OpenMM.
        Psi4 and OpenMM have different unit conventions. Psi4 does not label units,
        but typically takes units as Angstrom or Bohr. Internally, units are typically
        in Bohr. OpenMM typically uses nanometers, but units in OpenMM are treated as
        objects where every number has its value as well as its unit in a Unit object.

        In order to preserve clarity between programs, it is important to keep track of units. 
        The Molecule class here keeps all units in Angstroms. Because the Cartesian coordinates
        stored in Molecule.xyz are kept in a Numpy array, conversion between units is facile.

        If units other than Angstrom are passed in, the keyword argument unit should be set
        to the unit in place. Supported units (not case sensitive): 'Angstrom', 'Bohr', 
        'Nanometer'.

        z_vals : container of integers
            Container of z values (atomic numbers) of length N.
            Ex: [1, 1, 6, 6]
        xyz : container of container of doubles
            Container of Cartesian coordinates of N atoms. Dimensions (N, 3).
        """
        
        self.z_vals = np.array(z_vals)
        self.xyz = np.array(xyz)      

        unit = unit.lower()

        # if the units are not in angstrom, convert nanometers OR Bohr to Angstrom
        if unit != 'angstrom':
            self.xyz = self.xyz * 0.1 if unit == 'nanometer' else self.xyz / physconst.psi_bohr2angstroms 

        if self.xyz.shape[1] != 3:
            raise ValueError("XYZ should only have three coordinates")

        atom_indices = range(self.natoms())
        
        self.bonds = BFS_bonding.bond_profile(self)


    @staticmethod
    def from_xyz_string(xyz_string):
        """
        Create a molecule from a string.
        Zxyz_string : string
            Example and format:

            Atomic number   X    Y    Z
            _____________________________
            
            Zxyz_str = 'C               0.0  0.0  0.0
                        O               1.2  0.0  0.0'
        
        """
        z_vals = []
        xyz = []
        for line in xyz_string.splitlines():
            Zxyz_list = line.strip().split()
            if Zxyz_list == []:
                continue
            if len(Zxyz_list) != 4:
                raise KeyError("Line should have exactly 4 elements, Z, x, y, z.")

            z_vals.append(periodictable.el2z[Zxyz_list[0]])
            xyz.append([float(x) for x in Zxyz_list[1:]])

        return Molecule(z_vals, xyz)

    @staticmethod
    def from_xyz_file(filename):
        """
        Create a molecule from an xyz file.
        First line should be number of atoms, second line a comment,
        and subsequent lines (of length the number of atoms) atomic symbol
        and Cartesian coordinates.

        filename : string
            String of the name of the file containing the molecular input.
        """
        f = open(filename)
        data = f.read().splitlines()
        f.close()
        data_string = ""

        num_atoms = int( data[0].strip() )
        comment = data[1]

        for line in data[2:]:
            if len(line.split()) != 4: continue
            data_string += line + '\n'

        num_atom_lines = data_string.count('\n')+1
        if num_atom_lines != num_atoms:
            raise Exception("The XYZ file should contain %d atoms. It only contains %d lines (one atom per line)." % (num_atoms, num_atom_lines))

        return Molecule.from_xyz_string(data_string)
    
    def to_xyz_file(self, filename, comment=None):
        """
        Create an XYZ file with this molecule.
        
        filename : string
            Name of the new XYZ file.
        comment : string
            String to be placed on second line of XYZ file. 
        """
        output = str(self.natoms())
        output += ('\n'+comment if comment not None else '\n #Generated by GT')
        
        for atom in range(self.natoms()):
            output += '\n'
            output += "%3s  " % self.symbol(atom)
            output += '   '.join("% 10.6f" % x for x in self.xyz[atom])

        f = open(filename, 'w')
        f.write(output)
        f.close()
        return output 

    """TODO add mol2 file writer. Probably exists in qcdb of Psi4."""

    def natoms(self):
        """
        Return the number of atoms from the length of the xyz array.
        
        Returns
        -------
        int - the number of atoms
        """
        return self.xyz.shape[0]

    def distance(self, atom1, atom2):
        """
        Return the distance between two atoms in Angstroms.

        atom1, atom2 : int
            The index of atom1 and atom2 in the xyz array.
        
        Returns
        -------
        float - the distance in Angstroms
        """
        return np.linalg.norm(self.xyz[atom1]- self.xyz[atom2])

    def angle(self, atom1, atom2):
        """
        Compute the angle between the points at indices atom1, atom2, and atom3
        in the xyz array.

        atom1, atom2, atom3 : int
            The indicies of the atoms in the XYZ array.
        
        Returns
        -------
        float - the angle in radians.
        """
        point1 = np.asarray(mol.xyz[atom1])
        point2 = np.asarray(mol.xyz[atom2])
        point3 = np.asarray(mol.xyz[atom3])

        v1 = point2 - point1
        v2 = point3 - point1

        return np.arccos( np.dot(v1, v2) / np.linalg.norm(v1) / np.linalg.norm(v2) )

    def plane_perp_vec(self, atom1, atom2, atom3):
        """
        Compute the unit length vector perpendicular to the plane defined by points at indices atom1, atom2, and atom3
        in the xyz array.

        atom1, atom2, atom3 : int
            The indicies of the atoms in the XYZ array.

        Returns
        -------
        Length 3 Numpy array of floats
        """
        point1 = np.asarray(mol.xyz[atom1])
        point2 = np.asarray(mol.xyz[atom2])
        point3 = np.asarray(mol.xyz[atom3])
    
        v1 = point2 - point1
        v2 = point3 - point1
    
        perp_vec = np.cross(v1, v2)
    
        return perp_vec / np.linalg.norm(perp_vec)

    def dihedral(self, atom1, atom2, atom3, atom4)
        """
        Calculate the dihedral angle between four points.
        
        atom1, atom2, atom3, atom4 : int
            Indices of the four atoms in the XYZ array to calculate a dihedral angle from
        
        Returns
        -------
        float - the dihedral angle in radians
        """
        n1 = self.plane_perp_vec(atom1, atom2, atom3)
        n2 = self.plane_perp_vec(atom2, atom3, atom4)

        dihedral = - n1.dot(n2) / np.linalg.norm(n1) / np.linalg.norm(n2)
        dihedral = np.arccos([dihedral])

        return dihedral



    def symbol(self, atom1):
        """
        Return the chemical symbol of an atom. For example, 6 would yield 'C'.
        atom1 : int
            The index of atom1 in the z_vals array.
        
        Returns
        -------
        string - the chemical symbol
        """
        return periodictable._temp_symbol[int(self.z_vals[atom1])]



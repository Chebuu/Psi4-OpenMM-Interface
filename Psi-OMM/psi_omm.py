from sys import stdout
import itertools
import time
import numpy as np

import simtk.openmm.app 
import simtk.openmm 
from simtk.unit import *

from psi4.driver.qcdb import periodictable
from psi4.driver.qcdb import physconst 

import BFS_bonding
import molecule

#from simtk.openmm import *

# variables prefixed with 'po_' indicate objects for use linking Psi (the p) and OpenMM (the o)
# the po essentially means that these OpenMM objects have not been implemented to fully utilize
# all OpenMM functionality

# pdb.positions is list of tuples(Vec3 objects) w units [(x,y,z), (x,y,z)] nm

""" zvals is a list of atomic numbers, xyz is a list of lists [ [x,y,z] , [x,y,z] ], bonds is a list of two items: index 0 is as list of lists [ [atom1, atom2, bondorder] ], and index 1 is a list of lists where index 0 is atom 0 and the list at index 0 is the list of indices bonded to """

def make_topology(mol, chain_name=None, residue_name=None, res_id=None, unit_cell=(1,1,1)):
    """
    Method to make an OpenMM topology from a Molecule instance.
    For the current iteration of the interface, this method will
    be called when you want to add any new residue/chain; residues
    and chains are treated as being one and the same here since
    we don't typically use proteins.

    Currently this breaks some OpenMM features. Needs revision!

    mol : Molecule object
        Takes in a Molecule object which has z_vals, bonds, and atom_types.
    chain_name : string
        Name of chain to add to the Topology.
    residue_name : string
        Name of residue to add to the Topology.
    res_id : string
        id of residue to add to the Topology.
    unit_cell : length 3 Container 
        Dimensions of unit cell for the Topology. Pass in dimensions in nanometers as 
        normal float/integer values. Not necessary to pass in OpenMM Unit objects.

    Returns
    -------
    OpenMM Topology object 
    """
    # get the number of bonds; bonds[0] is a list of length 3 lists that contain
    # the atom indices of the two atoms in a bond as well as the bond order
    nbonds = len(mol.bonds[0])
    # instantiate an empty Topology object
    po_top = simtk.openmm.app.topology.Topology()
    
    po_chain = po_top.addChain("po_chain" if chain_name is None else chain_name)
    po_residue = po_top.addResidue("po_res" if residue_name is None else residue_name, po_chain, id=("po_res" if res_id is None else res_id))

    for a_ix in range(mol.natoms()):
        # add atoms to topology; here, the name we give each atom is its atom type
        # OpenMM labels all atoms with a unique id, thus it is fine to have equivalent names
        po_top.addAtom(mol.atom_types[a_ix], simtk.openmm.app.Element.getByAtomicNumber(mol.z_vals[a_ix]), po_residue)  

    # place the OpenMM Atom objects into a dictionary for simple access
    atoms_dict = {}
    for ix, at in enumerate(po_top.atoms()):
        atoms_dict[ix] = at

    # with the Atoms ordered above, we can now easily add the bonds 
    for b_ix in range(nbonds):
        # recall the mol.bonds[0] is ordered as [bond index][atom index 1, atom index 2, bond order]
        po_top.addBond(atoms_dict[mol.bonds[0][b_ix][0]], atoms_dict[mol.bonds[0][b_ix][1]])     

    po_top.setUnitCellDimensions( simtk.openmm.Vec3(unit_cell[0]*nanometer, unit_cell[1]*nanometer, unit_cell[2]*nanometer) )
    
    return po_top   

def get_atom_positions(topology, simulation):
    """
    Method to get atom positions from an OpenMM simulation
    by accessing the Simulation's Context. Converts atom positions
    to Angstroms.

    topology : OpenMM Topology object
        Topology object that contains the atoms we want to include in the trajectory.
    simulation : OpenMM Simulation object
        Simulation object that contains the Context that contains up to date atom 
        positions.
    
    Returns
    -------
    Tuple of (xyz, z_vals) where xyz is a Numpy array of length number of atoms (N)
    and z_vals is a Numpy array of length number of atoms of lists of length 3 (N, 3).
    """
    unit = None
    # retrieve atomic number and coordinates in Nanometers 
    z_vals, xyz = [], []
    for atom, xyz_tri in zip(topology.atoms(), simulation.context.getState(getPositions=True).getPositions()):
        z_vals.append( atom.__dict__['element'].atomic_number )
        xyz.append( [ xyz_tri[i].__dict__['_value'] for i in range(3) ] )
        unit = xyz_tri[0].__dict__['unit'].get_name().lower().strip()
    
    # Convert from nanometers to Angstroms if unit is nanometers
    unit_scaling = 10 if unit=='nanometer' else 1

    return (np.asarray(z_vals), np.asarray(xyz)*unit_scaling)


def write_traj(filename, z_vals, xyz, comment=" generated by Psi-OMM"):
    """
    Method to write trajectories for a simulation. 
    
    filename : string
        Name of file to write trajectory to.
    z_vals : container 
        Container of length number of atoms with atomic numbers of atoms.
    xyz : container
        Container of length number of atoms of containers of length 3.
    comment : string
        Comment to add in comment field of XYZ files that make up a trajectory.
        A nice standard would be to include the index of this snapshot in the comment.

    Yields
    ------
    New text file with name filename.
    """
    # create a Molecule instance and write the trajectory
    mol = molecule.Molecule(z_vals, xyz, unit='Angstrom')
    mol.to_xyz_file(filename, comment, append_mode='a')

def calc_mm_E(mol, forcefield=simtk.openmm.app.forcefield.ForceField('gaff2.xml')):
    """
    Method to calculate an OpenMM energy for an arbitrary geometry.
    Useful for post-analysis if the simulation is over but you still
    have the trajectory. Only returns potential energy as kinetic 
    energy is not able to be calculated from an XYZ file alone.

    mol : Molecule object
        Psi-OMM Molecule object that has z_vals and xyz and is able to 
        calculate atom_types or charges if it does not already have them. 
    forcefield : OpenMM ForceField
        Force field to use. Currently only GAFF atom types are able
        to be generated automatically, thus this is the default. If a force field
        other than GAFF is used, be sure that the atom_types in the Molecule
        object match. This is primarily included such that GAFF1 versus
        GAFF2 can be chosen.

    Returns
    -------
    float : OpenMM Potential Energy in kcal/mol
    """
    po_top = make_topology(mol)        
    omm_sys = simtk.openmm.app.forcefield.createSystem(top, nonbondedMethod=NoCutoff, atomTypes=mol.atom_types, atomCharges=mol.atom_charges)

    integrator = LangevinIntegrator(100*kelvin, 1/picosecond, 0.002*picoseconds)
    simulation = Simulation(po_top, omm_sys, integrator, platform=Platform.getPlatformByName('Reference'))

    # Create positions as desired by OpenMM; multiplication by .1 is to transform units from A to nm
    coords = []
    for i in range(len(mol.xyz)):
        coords.append(Vec3(mol.xyz[i][0]*.1, mol.xyz[i][1]*.1, mol.xyz[i][2]*.1))
    positions = coords * nanometer
    simulation.context.setPositions(positions)

    state = simulation.context.getState(getEnergy=True, getForces=False)
    #forces = state.getForces(asNumpy=True)
    energy = state.getPotentialEnergy()
    #print('MM ENERGY: ', energy/kilocalories_per_mole, 'KCAL/MOL ', energy)

    return energy/kilocalories_per_mole

def add_solvent(solute_mol, solvent_mol, num_solvent=None, box_size=(10,10,10), stacked=True):
    """
    Add solvent around a solute. This method is very rudimentary and adds solvent
    around a rectangular box which surrounds the solute. Thus, for accurate structures
    a energy minimization must be performed after use of this method. The solvent is 
    added on a grid whose size is determined by the size of the solvent which is also
    modeled as a rectangle.
    
    TODO: Change from rectangle with padding around solvent to a Van Der Waals radii based
    approach.

    The solvent is added radially around the solute. Thus, with enough solvent molecules added, 
    the entire solute/solvent system will approximate a sphere. 

    In OpenMM, there exists a method to addSolvent, but it only adds water molecules. In order to 
    use other solvents (and not use PDB files), this method exists. When OpenMM adds solvent molecules,
    the standard appears to be to create a new Chain for the solvent system. Within this Chain, every
    individual solvent molecule becomes a Residue. In order to keep track of individual solvent molecules,
    set stacked=False.

    solute_mol : Psi-OMM Molecule
        Psi-OMM Molecule representing the solute system. Only needs to contain
        xyz - this is required of all Psi-OMM Molecules, thus any Psi-OMM 
        Molecule will work.
    solvent_mol : Psi-OMM Molecule
        Psi-OMM Molecule representing a single solvent molecule. See solute_mol.
    num_solvent : int
        Number of solvent molecules to add around the solute.
    box_size : tuple
        Tuple of box dimensions to fill with solvent. Dimensions should be
        in Angstroms.
    stacked : Boolean
        If True, returns the added solvent's z_vals and xyz arrays as single arrays;
        arrays would have the form [N] and [N,[3]].
        If False, z_vals and xyz will be lists of length num_solvent of z_vals and
        xyz arrays; lists would have form [N[1]] and [N[n,[3]]] where n is the 
        number of atoms in the solvent molecule.

    Returns
    -------
    Tuple of Numpy arrays of form described in stacked. Note that the returned
    arrays only contain information about the SOLVENT that has been added. In
    order to create a simluation with both the solute and solvent, the solute and
    solvent arrays will need to be combined.
    """
    z_arr_list = []
    xyz_arr_list = []

    t = time.time()
    solute_xyz = solute_mol.xyz
    solvent_xyz = solvent_mol.xyz

    # Pad the region around the solute
    solute_box = 2.0 * np.max(solute_xyz, axis=0)
    solute_box += 2.0

    # Center solvent
    solvent_xyz -= np.mean(solvent_xyz, axis=0)
    # Pad the region around the solvent
    solvent_box = 2.0 * np.max(solvent_xyz, axis=0)
    solvent_box += 1.25

    # Find the maximum allowable extent of the solvent molecules, constrained
    # by the box_size
    sphere_dist = np.linalg.norm(solvent_box)

    solvent_placed = 0

    # If the number of solvent molecules desired is not specified, add a default value of 5
    if num_solvent is None:
        num_solvent = 5

    ref_stacked_xyz = solute_xyz.copy()
    # Break the addition of solvent into radial shells; default number of 
    # shells is up to 30 which seems to typically work well.
    for nshell in range(1, 30):
        if solvent_placed >= num_solvent:
            break

        #print('Starting shell %d, waters %d' % (nshell, solvent_placed))
        batch = 500 * nshell ** 2
        phi_x = np.random.rand(batch) * np.pi
        theta_x = np.random.rand(batch) * 2.0 * np.pi

        random_xyz = np.vstack((nshell * sphere_dist * np.cos(theta_x) * np.sin(phi_x),
                                nshell * sphere_dist * np.sin(theta_x) * np.sin(phi_x),
                                nshell * sphere_dist * np.cos(phi_x))).T

        for b in range(batch):
            displacement = random_xyz[b]

            distances = np.sum((ref_stacked_xyz - displacement)**2, axis=1) ** 0.5
            if np.any(distances < sphere_dist):
                #print('Skipping distance!')
                continue

            z_arr_list.append(solvent_mol.z_vals)
            xyz_arr_list.append(solvent_xyz + displacement)

            ref_stacked_xyz = np.vstack((ref_stacked_xyz, solvent_xyz + displacement))
            #output_xyz = np.vstack((output_xyz, solvent_xyz + displacement))
            #output_z_vals = np.vstack((output_z_vals, np.array([[x[0]] for x in solvent_geo_array])))

            solvent_placed += 1
            if solvent_placed >= num_solvent:
                break

    print( "Time to add solvent: ", time.time()-t)

    if stacked is False:
        return (z_arr_list, xyz_arr_list)

    else:
        # Need to stack the z_vals and xyz arrays
        stacked_z = np.hstack(tuple(z_arr_list))
        stacked_xyz = np.vstack(tuple(xyz_arr_list))
        return (stacked_z, stacked_xyz)    

def add_bonds(bonds1, bonds2):
    """
    Add the two bonds arrays together. For solute-solvent
    systems, the standard is that solute is added before
    solvent, thus bonds1 should be from solute and bonds2
    from solvent.

    bonds1 : Psi-OMM Bonds Array
    
    bonds2 : Psi-OMM Bonds Array

    Returns
    -------
    List of lists of lists in the form of the bonds array.
    """
    # Offset is equal to the number of atoms in the bonds1 array 
    offset = len(bonds1[1])

    ret_bonds0 = bonds1[0].copy()
    ret_bonds1 = bonds1[1].copy()

    for b0 in bonds2[0]:
        working_bond = b0.copy()
        # Increment the indices at working_bond[0] and [1] by
        # the offset.
        working_bond[0] += offset
        working_bond[1] += offset

        ret_bonds0.append(working_bond)

    for b1 in bonds2[1]:
        working_bond = b1.copy()
        # Increment every value in the list by offset.
        for ix in range(len(working_bond)):
            working_bond[ix] += offset

        ret_bonds1.append(working_bond)

    return (ret_bonds0, ret_bonds1)

def tile_bonds(bonds, reps, num_solvent_atoms):
    """
    Like the Numpy tile function, tile the bonds array.
    The Numpy tile function cannot be used because the 
    values in the bonds array need to be incremented by
    the number of atoms in the solvent molecules.

    bonds : Psi-OMM Bonds array
        The bonds array for the solvent molecule.
    reps : int
        Number of repeats of the bonds array. For a simple
        array, arr=[1,2], tile(arr, 3) would result in
        [1,2,1,2,1,2].
    num_solvent_atoms : int
        Number of atoms in the solvent molecule. This value
        is used to increment every atom index in the bonds array
        (this is every value except bond orders).

    Returns
    -------
    List of lists of lists in the form of the bonds array.
    """
    ret_bonds0 = bonds[0].copy()
    ret_bonds1 = bonds[1].copy()

    for tile_ix in range(1, reps):
        for b0 in bonds[0]:
            working_bond = b0.copy()
            # Increment the indices at working_bond[0] and [1] by
            # the num_solvent_atoms. working_bond[2] is the bond
            # order and should be left alone.
            working_bond[0] += num_solvent_atoms * tile_ix
            working_bond[1] += num_solvent_atoms * tile_ix

            ret_bonds0.append(working_bond)

        for b1 in bonds[1]:
            working_bond = b1.copy()
            # Increment every value in the list by num_solvent_atoms.
            for ix in range(len(working_bond)):
                working_bond[ix] += num_solvent_atoms * tile_ix

            ret_bonds1.append(working_bond)

    # Return the new tiled bond array in the form of a typical bonds
    # array, (bonds0, bonds1)
    return (ret_bonds0, ret_bonds1)



















###########################################################################
###########################################################################
#######                                                             #######
#######                                                             #######
#######                         DEPRECATED                          #######
#######                                                             #######
#######                                                             #######
###########################################################################
###########################################################################

def build_omm_system(top, bondinfo, psi_charges):
    forcefield = ForceField('gaff.xml', 'tip3p.xml')
    system = mm.System()
    
    # add atoms to system
    for atom in top.atoms():
        mass = forcefield._atomTypes[atom.name].mass
        system.addParticle(mass)

    """ COPIED from openmm forcefield.py and modified """
    """ PRIMARY MODIFICATIONS:
            bond.atom1 -> bond[0] because using bonds from topology
    """
    # build bondedToAtom from bondinfo[1] keys
    bondedToAtom = []
    for indexList in range(len(bondinfo[1])):
        bondedToAtom.append(bondinfo[1][indexList])
    
    uniqueAngles = set()
    for bond in top.bonds():
        for atom in bondedToAtom[bond[0]]:
            if atom != bond[1]:
                if atom < bond[1]:
                    uniqueAngles.add((atom, bond[0], bond[1]))
                else:
                    uniqueAngles.add((bond[1], bond[0], atom))
        for atom in bondedToAtom[bond[1]]:
            if atom != bond[0]:
                if atom > bond[0]:
                    uniqueAngles.add((bond[0], bond[1], atom))
                else:
                    uniqueAngles.add((atom, bond[1], bond[0]))
    uniqueAngles = sorted(list(uniqueAngles))
    
    uniquePropers = set()
    for angle in uniqueAngles:
        for atom in bondedToAtom[angle[0]]:
            if atom not in angle:
                if atom < angle[2]:
                    uniquePropers.add((atom, angle[0], angle[1], angle[2]))
                else:
                    uniquePropers.add((angle[2], angle[1], angle[0], atom))
        for atom in bondedToAtom[angle[2]]:
            if atom not in angle:
                if atom > angle[0]:
                    uniquePropers.add((angle[0], angle[1], angle[2], atom))
                else:
                    uniquePropers.add((atom, angle[2], angle[1], angle[0]))
    uniquePropers = sorted(list(uniquePropers))
    
    # Make a list of all unique improper torsions
    impropers = []
    
    for atom in range(len(bondedToAtom)):
        bondedTo = bondedToAtom[atom]
        if len(bondedTo) > 2:
            for subset in itertools.combinations(bondedTo, 3):
                impropers.append((atom, subset[0], subset[1], subset[2]))
    
    
    """ END copy """

    data = forcefield._SystemData()
    
    for atom in top.atoms():
        data.atomType[atom] = atom.name
        data.atomParameters[atom] = {}
        data.atoms.append(atom)
        data.excludeAtomWith.append([])
        data.isAngleConstrained.append(False)
        data.atomBonds.append([])
    
    for bond in top.bonds():
        data.bonds.append(ForceField._BondData(bond[0], bond[1]))
    
    data.angles = uniqueAngles
    data.propers = uniquePropers
    data.impropers = impropers
    
    for i in range(len(data.bonds)):
        bond = data.bonds[i]
        data.atomBonds[bond.atom1].append(i)
        data.atomBonds[bond.atom2].append(i)


    """ copied from openmm forcefield """
    
    # add forces
    args = ''
    #None
    nonbondedMethod =  NoCutoff
    nonbondedCutoff = 100*nanometer 
    removeCMMotion = True


    forcefield._forces[3].params.paramsForType['c3']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['c2']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['hc']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['oh']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['h1']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['hw']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['ho']['charge']=0.06217
    forcefield._forces[3].params.paramsForType['ow']['charge']=0.06217

    #for force in system.getForces():

    for force in forcefield._forces:
        force.createForce(system, data, nonbondedMethod, nonbondedCutoff, args)
   
    for force in system.getForces():
        if isinstance(force, NonbondedForce): 
            for i in range(system.getNumParticles()):
                charge, sigma, epsilon = force.getParticleParameters(i)
                force.setParticleParameters(i, psi_charges[i], sigma, epsilon)
                charge, sigma, epsilon = force.getParticleParameters(i)
                #print (data.atoms[i].name)
                #print "charge", charge, "sigma", sigma, "epsilon", epsilon



    if removeCMMotion:
        system.addForce(mm.CMMotionRemover())


    for force in forcefield._forces:
        if 'postprocessSystem' in dir(force):
            force.postprocessSystem(system, data, args)
    
    """ COPIED FROM PEASTMAN AT https://github.com/pandegroup/openmm/issues/1473 """
    
    """ IMPORTANT!!!! THIS IS HOW TO INDIVIDUALLY SET CHARGES FOR ATOMS THAT YOU WANT TO HAVE CHARGES DIFFERENT FROM THE CHARGES SET BY THE FORCEFIELD!"""
     
    
    """ end copy"""
    return system



def write_psi_in(filename, topology, simulation, mol):
    """
    Method to write basic Psi4 inputs from simulation data. Note that Psi4 can be
    run directly through Python. This method may be useful for
    longer jobs or for running many jobs simultaneously.

    filename : string
        Name of file
    basis : string
        String of Psi4 basis set to use
    method : string
        String of Psi4 method to use
    memory : string
        Amount of memory to use. Use Psi4 convention of value unit i.e. 30000 mb
        or 10 gb. Case insensitive.
    """

    f = open(filename, 'a')
    xyz_string = 'molecule{'
    for atom, xyz in zip(topology.atoms(), simulation.context.getState(getPositions=True).getPositions()):
        sym = atom.__dict__['element'].symbol
        xyz_string += " " + str(sym) + "  "
        for i in range(3):
            #xyz_string += str(xyz[i].__dict__['_value'])
            xyz_string += str(xyz[i].__dict__['_value']*10)
            xyz_string += "   "
        xyz_string += "\n"
    xyz_string += "}\n"
    f.write(xyz_string)
    f.write('memory 60000 mb\n')
    f.write("energy('b3lyp-d3/aug-cc-pvdz')")
    f.close()

def make_xyz_matrix(natom, simulation):
    # Make an XYZ matrix from openmm nanometer positions; return bohr positions
    psi_mat = np.zeros(shape=(natom,3))
    index = 0
    for xyz in simulation.context.getState(getPositions=True).getPositions():
        for i in range(3):
            psi_mat[index][i] = xyz[i].__dict__['_value']*10 / physconst.psi_bohr2angstroms 
        index += 1
    return psi_mat       

def b_weight(e_list, temp):
    # hartree/K
    k_b = 43.6e-19 * 1.381e-23
    Q = 0
    for e in e_list:
        Q += np.exp(-e / k_b / temp)
    p_list = []
    for e in e_list:
        p_list.append(e / Q)
    return p_list

def psi_mol_to_omm(psi_mol):
    z_vals = []
    xyz = []
    for atom_index in range(psi_mol.natom()):
        xyz.append([0]*3)
        xyz[atom_index][0] = psi_mol.x(atom_index) * physconst.psi_bohr2angstroms
        xyz[atom_index][1] = psi_mol.y(atom_index) * physconst.psi_bohr2angstroms
        xyz[atom_index][2] = psi_mol.z(atom_index) * physconst.psi_bohr2angstroms
        z_vals.append(periodictable.el2z[psi_mol.symbol(atom_index)])
        #z_vals.append(GAFF_Typer.periodictable.el2z[psi_mol.symbol(atom_index)])
    return (z_vals, xyz)
